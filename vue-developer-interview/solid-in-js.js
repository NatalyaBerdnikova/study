// Объектно-ориентированная парадигма
// Отличия процедурного программирования от объектно-ориентированного
// В процедурном программировании программа получает на вход какие-то данные, выполняет ряд процедур, и отдает результат
// Класс (описание характеристик) выступает фабрикой объектов, объекты - экземпляр класса, у него свойства имеют конкретные значения,
// также есть методы и могут быть события

// Инкапсуляция (Тесно пересекается с понятием сокрытие)
// Класс - является капсулой, которая содержит в себе свойства и методы для работы с этими свойствами
// Сокрытие - запрет на использование методов снаружи класса, создаются с помощью модификатора private
// В основном свойства создают приватными, а для доступа к ним используют функции геттеры и сеттеры
// По умолчанию методы имеют модификатор public

// Наследование
// Наследник наследует свойства родителя, и может иметь свои, также может переопределять методы
// В JS мы можем наследоваться только от одного класса
// class Employee extends Person { constructor() { super(); } }
// super(params) - вызов родительского конструктора

// Полиморфизм
// Выделяют 2 вида полиморфизма - параметрический(истинный) и ad-hoc(мнимый)
// Принцип позволяющий одному и тому же фрагменту кода работать с разными типами данных
// Мнимый происходит за счет перегрузки методов (2 метода с одинаковым названием работают с разными типами данных)
// Также мнимым полиморфизмом считается явное приведение дочернего класса к родительскому
// В параметрическом полиморфизме мы переопределяем методы под нужды конкретного класса.
// То есть у основного класса и его наследников есть метод с одинаковым названием делающий немного разные вещи

// Агрегация и композиция
// Композиция - это использование внутри класса объекты других классов. Также характерно для композиции, эти объекты не могут быть использованы отдельно.
// Объекты инициализируются внутри основного класса class Car { this.engine = new Engine(); }
// Агрегация - объект используемый в другом классе передается из вне и может быть использован в других обстоятельствах.
// constructor(freshener) { this.freshener = freshener; }
// Делегирование, вызывая один метод у основного класса используются методы классов композиции.

// Абстрактные классы и интерфейсы
// Интерфейс - содержит в себе описание методов, какие параметры принимают, какого типа и что возвращают, но не содержит реализации
// Из интерфейса нельзя сделать объект
// Абстрактный класс - похожи на интерфейсы, в них также можно объявлять методы без реализации, но можно и с ней.
// Класс наследник абстрактного класса наследует все методы, но должен будет реализовать абстрактные методы
// class FileClient implements Reader, Writer < реализовывает все методы которые есть в интерфейсах
// Имплементировать мы можем неограниченное количество интерфейсов
// Интерфейсы позволяют писать более гибкий код с большим уровнем полиморфизма
// T - дженерик, что-то общее что приходит из вне
// interface Repository<T> { read(obj: T) => T }
// На этапе проектирования создаем интерфейс и определяем какие должны быть методы. А потом подстраиваясь под этот интерфейс реализуем классы

// Dependency injection
// TODO

// SOLID
// Single Responsibility
// Принцип единой ответственности - одна сущность должна решать одну задачу

// Open/Closed principle
// Принцип открытости/закрытости - программные сущности должны быть открыты для расширения, но закрыты для модификации
// При изменении работающего кода необходимо выполнять регрессионное тестирование (что изменения ничего не сломали)

// Liskov's Substitution principle
// Принцип подстановки Барбары Лисков - сущности использующие родительский тип, должны также работать с его наследниками, и ничего не должно ломаться
// Наследник должен дополнять функциональность, а не подменять

// Interface Segregation
// Принцип разделения интерфейса - программные сущности не должны зависеть от методов, которые они не используют.
// Нельзя заставлять клиента реализовывать интерфейс, которым он не пользуется
// Делать супер-общее решение - скорее антипаттерн, чем хорошее решение
//

// Dependency inversion
// Принцип инверсии зависимости - Модули высокого уровня не должны зависеть от модулей более низкого уровня.
// Все они должны зависеть от абстракций. А абстракции не должны зависеть от деталей.
// Детали должны зависеть от абстракций.
// В случае нарушения, при каком-то изменении деталей нам необходимо вручную менять некоторые сущности или модули более высокого уровня.
// Хорошо иметь для разных реализаций общий интерфейс, чтобы ничего не ломалось при их подмене.
//
