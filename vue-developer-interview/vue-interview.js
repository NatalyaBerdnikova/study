// Жизненный цикл компонента
// 1 Вызывается конструктор new Vue()
// 2 Перед созданием объекта Vue вызывается метод beforeCreate()
// 3 Далее происходит инициализация объекта Vue, установка его данных и методов
// 4 После создания объекта Vue вызывается метод created()
// 5 Далее выполняется компиляция шаблона
// 6 Вызывается метод beforeMount()
// 7 Элемент html, к которому прикреплен объект Vue, заменяется скомпилированным шаблоном
// 8 Вызывается метод mounted(), и после этого шаблон прикреплен к DOM, и мы можем с ним работать
// 9 Если в процессе работы мы обновляем данные объекта Vue, то происходит еще ряд событий:
// 10 Данные изменяются
// 11 Вызывается метод beforeUpdate()
// 12 Производится повторный рендеринг DOM для его соответствия виртуальному DOM
// 13 Вызывается метод updated(). DOM на веб-странице обновлен, и мы продолжаем работать с приложением Vue.js
// 14 При завершении работы приложения вызывается метод beforeDestroy()
// 15 И в конце вызывается метод destroyed(). Объект Vue удалено из памяти, и больше с ним мы работать не можем.

// -------------------------------------------------------------------------------------------------------------

// 50 вопросов на Vue js собеседование
// https://www.youtube.com/watch?v=umHjpWydn8I

// 1. Что такое двустороннее связывание
// Позволяет динамически менять значение на одном конце привязки при изменении на другом конце
// Связывание графического интерфейса с данными, с которыми мы работаем

// <input type="text" v-model="email" />
// data() {
//   return {
//     email: ''
//   }
// }

// 2. Какими способами можно реализовать двустороннее связывание для input
// Как выше ^^ или
// <input type="text" value="email" @input="email = $event.target.value" />
// data() {
//   return {
//     email: ''
//   }
// }

// 3. Что такое props
// Это входные параметры, пользовательские атрибуты, которые может принимать компонент. Действуют как его стандартные свойства
// Можем использовать в любом месте компонента.

// 4. Как работает реактивность во Vue
// Концепция, которая позволяет адаптироваться к изменениям данных декларативным способом
// Изменили данные в коде > Обновилось их представление на странице
// Для реактивности во Vue 3 используется JS Object Proxy
// А во 2 Object.defineProperty - который позволяет навесить getter и setter на модель данных

// 5. Что такое Composition API во Vue 3
// Новая функциональность во Vue 3, для большей переиспользуемости кода и улучшения читаемости компонентов
// Возможность хранить данные отдельно от компонентов, возможность создавать реактивные переиспользуемые куски кода

// 6. Особенности использования v-model во Vue 2 и Vue 3
// По умолчанию во второй версии можно использовать только 1 v-model, и обязателен слушатель onInput
// В третьей версии можно использовать сколько угодно v-model:title => title
// Если название атрибута не указано, то по умолчанию это будет modelValue (value по умолчанию во 2 версии)
// this.$emit('input', newValue) - 2
// this.$emit('update:title', newValue) - 3

// 7. Для чего нужен $emit
// Поскольку передача данных происходит сверху вниз, от ребенка к родителю мы можем
// переданные данные с помощью emit/события

// 8. Постраничная навигация во Vue (SPA)
// Можно использовать библиотеку Vue-router, куда мы можем передать массив маршрутов
// Указываем для каждого роута путь и компонент
// Регистрируем роутер
// И чтобы вмонтировать компонент по определенному пути используем компонент router-view
// Для ссылок используем router-link

// 9. Что такое computed свойства и как они работают
// Позволяют закэшировать результат вычислений, и обновляются если
// использованные внутри переменные/модели изменяются

// 10. Как отследить изменение модели
// watch: {} - наблюдаемые свойства.
// Функция, которая называется также как и модель

// watch: {
// counter(newValue) {
// console.log('Counter changed - ', newValue);
// }
// }

// 11. Особенности слежения за "глубокими" объектами
// Для свойства в watch нужно добавить свойства handler и deep: true

// 12. Что такое интерполяция
// Форма привязки для отображения данных в шаблоне

// 13. Как отрисовать компонент по условию
// v-if="", v-else, v-else-if=""

// 14. Разница между v-if и v-show
// v-show - Нельзя использовать с v-else. v-if - не рендерит компонент, а
// v-show просто добавляет инлайн-стили display: none

// 15. Что такое миксины и как их использовать
// Миксин как кусочек компонента, некоторый переиспользуемый функционал
// mixins: [CountMixin]

// 16. Что такое директивы
// Это специальные атрибуты, которые мы можем использовать внутри html шаблона
// v-text, v-bind, v-slot, v-once
// Позволяет добавить новую функциональность и сократить количество кода

// 17. Как создать пользовательскую директиву. Особенности использования
// У каждой директивы есть методы жизненного цикла (mounted, unmounted)
// Аргументом принимают el, к которому директива была применена
// app.directive('scroll', VScroll) - Регистрация, название директивы и компонент
// Также в директиву мы можем передавать данные, например функцию
// mounted(el, binding) { el.onscroll = binding.value() }
// unmounted(el) { el.onscroll = null }

// 18. Жизненный цикл компонента vue
// Инициализация
// С помощью lifecycle hooks мы можем следить за жизненным циклом
// beforeCreate, created, beforeMount, mounted, beforeUpdate, updated, beforeUnmount, unmounted

// 19. В каком методе жизненного цикла необходимо делать первичную загрузку данных с сервера
// В методе mounted, так как компонент уже готов к использованию

// 20. В каком методе жизненного цикла необходимо делать очистку(слушатель, хранилище)
// unmounted (?) - когда компонент был демонтирован

// 21. Как сделать стили локальными для компонента
// Атрибут scoped на теге style

// 22. Как отрисовать несколько компонентов на основе массива
// v-for="el in list" :key="el.id"

// 23. Зачем указывать key?
// Для оптимизации списков, перендерить только те участки, которые изменились
// key желательно должен быть статичным и уникальным

// 24. Как отследить изменение поля объекта
// watch: { 'user.address.street'(newValue) { console.log(newValue) } }

// 25. Как добавить слушателя события на элемент
// v-on:click = @click

// 26. Что такое модификаторы
// Дополнение для директивы, чтобы изменить/дополнить ее поведение
// Для v-model и событий

// 27. Какие модификаторы есть у событий
// prevent, stop, once, self, отследить нажатие любой кнопки ctrl, alt

// 28. Какие модификаторы есть у v-model?
// number, lazy, trim (lazy меняет слушание input на on change)

// 29. Как добавить анимацию на удаление/добавление элемента в список
// Встроенный компонент transition-group, обернуть им группу элементов с v-for
// list-enter-active, list-leave-active {transition: all 0.15s ease-out}
// list-enter-from, lister-leave-to {opacity: 0, transform: translateX(10px)}

// 30. Как зарегистрировать компонент глобально во Vue 3
// app.component('myComponent', myComponent)

// 31. Как передать данные из родительского компонента в дочерний, не используя
// props и store
// Provide/Injection
// provide() { return { user: this.user } }
// inject: [user]

// 32. Как добавить класс на элемент по условию
// :class="{ green: toggle }"

// 33. Как динамически изменять стили у элемента
// :style="{ backgroundColor: color }"

// 34. Слоты Vue
// <slot></slot> для вставки компонента, как children в React
// <slot name="header"></slot> - именованные слоты
// <template v-slot:header></template>
// <template v-slot:body></template>

// 35. Каким способом можно получить DOM элемент во Vue
// Можно указывать элементам в шаблоне ref="inputref"
// console.log(this.$refs.inputref)

// 36. Предназначение keep-alive во Vue
// Кеширует компонент, не демонтирует его из DOM

// 37. Зачем нужны телепорты во Vue
// <teleport to="body"><div> </div></teleport>
// TODO: Зачем нужны

// 38. Как подключить внешний плагин во Vue 3
// app.use(vuex)
// app.use(vueRouter)

// 39. Как создать свой собственный Vue плагин во Vue 3
// Нужно создать объект, у которого будет метод install
// export default {
// install: (app, options) => {
// Код плагина
// }
// }
// Также нужно зарегистрировать. Внутри можно создавать свои директивы

// 40. При использовании хуков жизненного цикла в миксине и при подключении этого
// миксина в компонент, в какой последовательности будут вызываться хуки?
// Сначала отработают хуки из миксинов по порядку, а потом хуки компонента

// 41. Почему не стоит использовать в качестве ключей key массива?
// Ключ должен быть статичен и уникален. При изменении массива, индексы элементов
// также поменяются. Пропадает эффективность использования ключей

// 42. Почему этот код не работает
// array.filter(el => el % 2 !== 0);
// Функция filter возвращает новый массив, а не фильтрует массив на месте

// 43. Можно ли использовать v-if и v-for на одном элементе?
// Лучше так никогда не использовать. Для фильтрации лучше использовать computed свойства
// А для сокрытия списка лучше помещать v-if на элемент контейнера.
// TODO

// 44. Можно ли изменять computed свойства
// Не рекомендуется. Необходимо изменять одну из зависимостей, используемых в этом свойстве
// TODO

// 45. Для чего нужен Vuex и какие проблемы он решает?
// Паттерн для управления состоянием. Также служит централизованным хранилищем
// данных для всех компонентов.
// Избавляет от необходимости прокидывать данные сверху вниз по иерархии
// Гарантирует, что состояние может быть изменено только предсказуемым образом
// А именно с помощью мутаций и actions

// 46. Расскажите о state и getters во vuex
// Vuex содержит все дерево состояний, и является единственным источником истины.
// В state мы храним данные, а getters - это функции для чтения этих данных из state
// Как computed свойства в компоненте, также кеширует их

// 47. Расскажите о мутациях и действиях во Vuex. В чем отличие?
// Мутации единственный способ изменить состояние. Это функция, которая внутри себя
// меняет какие-либо поля объекта состояния
// Actions содержат в себе некоторые side-effects, запросы к серверу, таймеры
// Но при этом внутри себя они вызывают мутации для изменения состояния
// Мутации всегда являются синхронными, и не могут содержать асинхронную логику

// 48. Как использовать store внутри компонента
// После глобальной регистрации стора, можно использовать this.$store
// Также есть специальные функции
// computed: { ...mapState(), ...mapGetters() }, methods: { ...mapMutations, ...mapActions() }

// 49. Как принудительно обновить компонент в Vue
// this.$forceUpdate();

// 50. Для чего нужны асинхронные компоненты во Vue
// Для загрузки компонентов, только тогда когда они необходимы
// defineAsyncComponent

// -----------------------------------------------------------------------------------------
// Общие вопросы
// В чем разница между == и ===
// == сравнивает с приведением типов 0 == false - true и 1 == "1" - true

// 4 способа объявления переменной
// a = 1; var a = 2; let c = 4; const b = 3;
// 1 и 2 способ имеют глобальную или функциональную область видимости, но не блочную, сейчас считаются устаревшими способами

// Различие между function и arrow function
// Обращение к this происходит к this снаружи, нет собственного
// Нельзя использовать arguments
// Синтаксис
// Не могут быть вызваны с new

// Что такое замыкание
// Это функция вместе со всеми внешними переменными, которые ей доступны
// Вложенная функция, будет замыкать и сохранять внутри себя переменные, которые объявлены в родительской

// Шаблонные литералы `` - нужны для использования внутри выражений через ${}, и для использования внутри переноса строк

// Map - структура данных ключ/значение, как Object, позволяет использовать ключи любого типа
// Set - особый вид коллекции, множество значений без ключей. Каждое значение может появляться только один раз

// Как определить наличие свойства в объекте: obj.hasOwnProperty('a');
// b in obj

// Ложные значения
// false, 0, null, undefined, '', NaN, BigInt(0)

// Оператор spread нужен для того чтобы разворачивать массивы и объекты
// const mid = [3, 4]
// const a = [1, 2, ...mid, 5, 6]; < [1, 2, 3, 4, 5, 6]

// Как избежать ссылочной зависимости при копировании объекта
// Object.assign({}, obj) - копирует объект, но оставляет ссылки на поля внутри
// JSON.parse(JSON.stringify(obj)) - ссылочная зависимость уходит

// Как поменять контекст для функции
// .bind, .call, .apply - call принимает параметры через запятую, а apply массивом. Последние две вызывают функцию сразу

// DOM - объектное представление структуры HTML документа в JS, которое представлено в виде структурны данных дерево

// Из чего состоит HTTP запрос
// Строка запроса (request line) - метод запроса, url адрес, и версию протокола
// Заголовки (message header) - описывают тело сообщения, передают параметры
// Тело сообщения (entity body) - данные, которые передаются в запросе, не обязателен
// Методы: GET, POST, PUT, DELETE
// Websocket - протокол, который нужен для взаимодействия в реальном времени
// Основная идея REST API заключается в разделении операций, при обращении к одному и тому же URL, используя HTTP

// Атрибут defer для тега script - загружает скрипт, но не исполняет его, тем самым ничего не блокируя
// Перед событием о том что документ загружен, исполняются defer скрипты

// Вопросы, на которые я не ответила с собеседования в Айти Спешл
// hoisting
// prototype как работает
// контекст объекта и функции
// Замыкание это не только про функции
// Токены (Как хранить токен авторизации юзера и отправлять при запросах)
// localStorage для хранения токена юзера
// use strict
// object.freeze
// что такое промис
// принцип работы event loop
// node.js
// что такое класс js
// область видимости var и let
// когда вызывается updated
// реализация map

// что такое сервисы http сервис
// Задачи не связанные c бизнес логикой
//

// SSR -
