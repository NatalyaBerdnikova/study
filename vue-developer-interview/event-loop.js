// https://www.youtube.com/watch?v=zDlg64fsQow&list=WL&index=2
// Архитектура браузера:
// 1. User Interface (Строка поиска, кнопки вперед-назад)
// 2. Browser Engine (Соединительная часть между пользователем и движком рендера)
// 3. Render Engine (Webkit в Chrome, Gecko в Firefox)
// 4. Networking (Работа с сетью, история посещения сайтов, доменные имена, взаимодействие с DNS сервером, https)
// JS Interpreter (Обработка js кода, движок v8 используется и в браузере и в node.js)
// Предоставляет heap - кучу, область памяти для хранения объектов, массивов и функций, стек вызовов(работа с памятью - выделение, сборка мусора), также компилирует javascript в машинный код
// Backend UI (Предоставляет логику работы самого браузера)
// 5. Data Persistence - хранение данных (Local Storage, Session Storage, Idb, websql, file system)
// Cookie, работа со вкладками сюда же

// Event loop - механизм, позволяющий использовать неблокирующую модель ввода и вывода

// Call stack - стек вызовов. По количеству возможных в нем операций ограничен. И если, например, запустить рекурсивную функцию с очень большим
// количеством циклов, то стек будет переполнен и приложение упадет с ошибкой
// Event loop содержит внутри себя очередь Task queue (очередь задач)
// Задачи из очереди выполняются только после вызова всех функций из стека

// За очередь отвечает event loop
// А за call stack отвечает движок Javascript (v8 в Chrome, JavaScriptCore в Safari, Chakra в microsoft edge, SpiderMonkey в Mozilla)

// Движок отвечает за:
// Куча (heap) и стек вызовов (call stack)
// Работа с памятью (Выделение и сбор мусора)
// Компиляция JS в машинный код
// Оптимизация (кеши, скрытые классы и прочее)

// Event loop не является частью движков. Цикл события предоставляется средой (браузер или node.js)
// Web API отправляет задачи в task queue, и оттуда когда call stack свободен в него отправляются таски
// Macrotask queue (очередь событий) setTimeout, setInterval, события (клик, загрузка), браузерные нюансы (рендер, I/O)
// Microtask queue (очередь задач) Promise, queueMicrotask, mutationObserver
// Очередь microtasks имеет больший приоритет. Микротаски выполняются сразу все, и потом выполняется одна макротаска
// Если макротаска порождает микротаски, то сначала выполняются они, и затем снова макротаска

// Render
// 0. DOM > CSSOM > Render tree >
// 1. Style calculation (Применение селекторов к элементам)
// 2. Layout (По размерам и позиции расставляет элементы) > Layout tree
// 3. Paint (Рисует из чертежа пиксели)
// 4. Compositing (Работа со слоями) layer tree
// При изменении каких-либо значений с помощью JS, все эти стадии проходятся заново.
// Рендер - дорогостоящая операция

// Операции которые вызывают ререндер:
// Изменение размера окна (resize), шрифта, контента
// Добавление/Удаление классов/стилей
// Манипуляции с DOM-деревом напрямую
// Изменение ориентации (альбом/книга), размеров/позиции
// Вычисление размеров/позиции
// Задачи рендера запускаются до макротасок, после микротасок и синхронного кода

// Node.js - программная платформа, позволяющая превращать Javascript в машинный код
// Позволяет взаимодействовать с устройствами ввода/вывода через свой API, написанный на С++
// Движок v8 транслирует JS в машинный код, Libuv предоставляет кроссплатформенный I/O (ввод-вывод), цикл событий Event Loop
// кроссплатформенный I/O подразумевает работу с файловой системой, с сетью
// nginx - неблокирующий ввод/вывод
// apache - классический многопоточный веб-сервер с блокирующей моделью поведения
// на каждое соединение открывается новый поток

// Сам JavaScript - однопоточный, а асинхронность достигается за счет event loop
// Libuv содержит 4 потока по умолчанию и может ими управлять
// Node.js - одопоточные, но некоторые библиотеки могут быть многопоточными
// С версии node.js 11.7.0 можно управлять потоками из кода с помощью worker_threads

// Демультиплексор событий (шаблон reactor) для работы с неблокирующим ввод/вывод
// Осуществляет сборку и постановку в очередь событий ввода и вывода, которые поступают из набора наблюдаемых ресурсов
// А также блокировку появления новых доступных для обработки событий
// Коротко, это интерфейс уведомления о событиях

// Event loop в Node.js
// Входящие соединения, данные и т.д.
// Promises > Таймеры > I/O Callbacks > Ожидание, подготовка > Опрос > Проверка > Callbacks 'close'
// в Node.js 6 очередей(+ промисы), и все задачи из этих очередей выполняются одна за одной
// Глобально event loop решает задачи асинхронности
